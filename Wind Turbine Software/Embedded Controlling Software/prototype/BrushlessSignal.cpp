/*
  BrushlessSignal.cpp - Library for reading brushless signal.
*/

#include "Arduino.h"

#include "BrushlessSignal.h"

BrushlessSignal::BrushlessSignal() {}

/** Attaches brushless to given pin and initializes it
   @param analog_pin STEPPER_PIN
*/
void BrushlessSignal::attach(uint8_t analog_pin, uint8_t opt_pin1, uint8_t opt_pin2) {
  this->FFT = arduinoFFT();
  this->brushless.attach(analog_pin);
  this->optocoupler1.attach(opt_pin1);
  this->optocoupler2.attach(opt_pin2);

  this->optocoupler1.write(LOW); // scale = 1 (V <= 1,5V)
  this->optocoupler2.write(HIGH); // scale = 2 (1,5V <= V <= 3)
}

/** Runs some iterations to obtain reliable voltages from the brushless
*/
void BrushlessSignal::run() {
  unsigned long loop_time = 0;
  this->peak_voltage = 0;
  for (int i = 0; i < SAMPLES; ++i) {
    this->real_voltage[i] = (brushless.read() * (3.3 / 4096.0) - OFFSET) / SCALE;
    this->imaginary_voltage[i] = 0;
    this->peak_voltage = max(this->real_voltage[i], this->peak_voltage);
    // Regulate to approximately "SAMPLE_PERIOD" (max depends on BAUD and computer speed)
    while ((micros() - loop_time) < toMicros(SAMPLE_PERIOD));
    loop_time = micros();
  }
}

/** Reads revolutions frequency generated by the brushless
   @return frequency generated by the brushless
*/
float BrushlessSignal::readFrequency() {
  this->FFT.Windowing(this->real_voltage, SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD);
  this->FFT.Compute(this->real_voltage, this->imaginary_voltage, SAMPLES, FFT_FORWARD);
  this->FFT.ComplexToMagnitude(this->real_voltage, this->imaginary_voltage, SAMPLES);
  this->FFT.DCRemoval(this->real_voltage, SAMPLES);
  float frequency = FFT.MajorPeak(this->real_voltage, SAMPLES, SAMPLE_RATE);
  // High pass filter
  if (frequency < HIGH_PASS_FILTER) {
    frequency = 0;
  }
  return frequency;
}

/** Reads power generated by the brushless
   @param status status of turbine
   @return power generated in mW
*/
float BrushlessSignal::readPower(Status const &status) {
  this->rms_voltage = this->peak_voltage / sqrt(2);
  return toMillis(pow(this->rms_voltage, 2) / status.resistance);
}
